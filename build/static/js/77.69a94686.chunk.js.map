{"version":3,"sources":["../../../src/container.ts","../../../src/metadata/ConstraintMetadata.ts","../../../src/metadata/ValidationMetadata.ts","../../../src/validation/ValidationTypes.ts","../../../src/validation-schema/ValidationSchemaToMetadataTransformer.ts","../../../src/metadata/MetadataStorage.ts","../../../src/decorator/common/ValidateBy.ts","../../../src/register-decorator.ts","../../../src/utils/get-global.util.ts"],"names":["userContainer","userContainerOptions","defaultContainer","instances","get","someClass","instance","this","find","type","object","push","getFromContainer","fallback","error","fallbackOnErrors","target","name","async","args","groups","each","context","undefined","propertyName","constraints","constraintCls","validationTypeOptions","validationOptions","message","always","isValid","Object","keys","map","key","indexOf","CUSTOM_VALIDATION","NESTED_VALIDATION","PROMISE_VALIDATION","CONDITIONAL_VALIDATION","WHITELIST","IS_DEFINED","transform","schema","metadatas","properties","forEach","property","validation","options","ValidationMetadata","validationMetadatas","constraintMetadatas","length","addValidationSchema","validationMetadata","addValidationMetadata","metadata","addConstraintMetadata","groupByPropertyName","grouped","getTargetValidationMetadatas","targetConstructor","targetSchema","strictGroups","includeMetadataBecauseOfAlwaysOption","excludeMetadataBecauseOfStrictGroupsOption","originalMetadatas","filter","group","uniqueInheritedMetadatas","Function","prototype","inheritedMetadata","originalMetadata","concat","getTargetValidatorConstraints","getMetadataStorage","global","classValidatorMetadataStorage","buildMessage","impl","validationArguments","eachPrefix","ValidateBy","validator","validate","value","defaultMessage","validationMetadataArgs","ValidationTypes","registerDecorator","constructor","getGlobal","globalThis","window","self"],"mappings":"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","file":"static/js/77.69a94686.chunk.js","sourcesContent":["/**\n * Container options.\n */\nexport interface UseContainerOptions {\n  /**\n   * If set to true, then default container will be used in the case if given container haven't returned anything.\n   */\n  fallback?: boolean;\n\n  /**\n   * If set to true, then default container will be used in the case if given container thrown an exception.\n   */\n  fallbackOnErrors?: boolean;\n}\n\n/**\n * Container to be used by this library for inversion control. If container was not implicitly set then by default\n * container simply creates a new instance of the given class.\n */\nconst defaultContainer: { get<T>(someClass: { new (...args: any[]): T } | Function): T } = new (class {\n  private instances: { type: Function; object: any }[] = [];\n  get<T>(someClass: { new (...args: any[]): T }): T {\n    let instance = this.instances.find(instance => instance.type === someClass);\n    if (!instance) {\n      instance = { type: someClass, object: new someClass() };\n      this.instances.push(instance);\n    }\n\n    return instance.object;\n  }\n})();\n\nlet userContainer: { get<T>(someClass: { new (...args: any[]): T } | Function): T };\nlet userContainerOptions: UseContainerOptions;\n\n/**\n * Sets container to be used by this library.\n */\nexport function useContainer(iocContainer: { get(someClass: any): any }, options?: UseContainerOptions): void {\n  userContainer = iocContainer;\n  userContainerOptions = options;\n}\n\n/**\n * Gets the IOC container used by this library.\n */\nexport function getFromContainer<T>(someClass: { new (...args: any[]): T } | Function): T {\n  if (userContainer) {\n    try {\n      const instance = userContainer.get(someClass);\n      if (instance) return instance;\n\n      if (!userContainerOptions || !userContainerOptions.fallback) return instance;\n    } catch (error) {\n      if (!userContainerOptions || !userContainerOptions.fallbackOnErrors) throw error;\n    }\n  }\n  return defaultContainer.get<T>(someClass);\n}\n","import { ValidatorConstraintInterface } from '../validation/ValidatorConstraintInterface';\nimport { getFromContainer } from '../container';\n\n/**\n * This metadata interface contains information for custom validators.\n */\nexport class ConstraintMetadata {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  /**\n   * Target class which performs validation.\n   */\n  target: Function;\n\n  /**\n   * Custom validation's name, that will be used as validation error type.\n   */\n  name: string;\n\n  /**\n   * Indicates if this validation is asynchronous or not.\n   */\n  async: boolean;\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(target: Function, name?: string, async: boolean = false) {\n    this.target = target;\n    this.name = name;\n    this.async = async;\n  }\n\n  // -------------------------------------------------------------------------\n  // Accessors\n  // -------------------------------------------------------------------------\n\n  /**\n   * Instance of the target custom validation class which performs validation.\n   */\n  get instance(): ValidatorConstraintInterface {\n    return getFromContainer<ValidatorConstraintInterface>(this.target);\n  }\n}\n","import { ValidationMetadataArgs } from './ValidationMetadataArgs';\nimport { ValidationArguments } from '../validation/ValidationArguments';\n\n/**\n * This metadata contains validation rules.\n */\nexport class ValidationMetadata {\n  // -------------------------------------------------------------------------\n  // Properties\n  // -------------------------------------------------------------------------\n\n  /**\n   * Validation type.\n   */\n  type: string;\n\n  /**\n   * Target class to which this validation is applied.\n   */\n  target: Function | string;\n\n  /**\n   * Property of the object to be validated.\n   */\n  propertyName: string;\n\n  /**\n   * Constraint class that performs validation. Used only for custom validations.\n   */\n  constraintCls: Function;\n\n  /**\n   * Array of constraints of this validation.\n   */\n  constraints: any[];\n\n  /**\n   * Validation message to be shown in the case of error.\n   */\n  message: string | ((args: ValidationArguments) => string);\n\n  /**\n   * Validation groups used for this validation.\n   */\n  groups: string[] = [];\n\n  /**\n   * Indicates if validation must be performed always, no matter of validation groups used.\n   */\n  always?: boolean;\n\n  /**\n   * Specifies if validated value is an array and each of its item must be validated.\n   */\n  each: boolean = false;\n\n  /*\n   * A transient set of data passed through to the validation result for response mapping\n   */\n  context?: any = undefined;\n\n  /**\n   * Extra options specific to validation type.\n   */\n  validationTypeOptions: any;\n\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n\n  constructor(args: ValidationMetadataArgs) {\n    this.type = args.type;\n    this.target = args.target;\n    this.propertyName = args.propertyName;\n    this.constraints = args.constraints;\n    this.constraintCls = args.constraintCls;\n    this.validationTypeOptions = args.validationTypeOptions;\n    if (args.validationOptions) {\n      this.message = args.validationOptions.message;\n      this.groups = args.validationOptions.groups;\n      this.always = args.validationOptions.always;\n      this.each = args.validationOptions.each;\n      this.context = args.validationOptions.context;\n    }\n  }\n}\n","/**\n * Validation types.\n */\nexport class ValidationTypes {\n  /* system */\n  static CUSTOM_VALIDATION = 'customValidation'; // done\n  static NESTED_VALIDATION = 'nestedValidation'; // done\n  static PROMISE_VALIDATION = 'promiseValidation'; // done\n  static CONDITIONAL_VALIDATION = 'conditionalValidation'; // done\n  static WHITELIST = 'whitelistValidation'; // done\n  static IS_DEFINED = 'isDefined'; // done\n\n  /**\n   * Checks if validation type is valid.\n   */\n  static isValid(type: string): boolean {\n    return (\n      type !== 'isValid' &&\n      type !== 'getMessage' &&\n      Object.keys(this)\n        .map(key => (this as any)[key])\n        .indexOf(type) !== -1\n    );\n  }\n}\n","import { ValidationSchema } from './ValidationSchema';\nimport { ValidationMetadata } from '../metadata/ValidationMetadata';\nimport { ValidationMetadataArgs } from '../metadata/ValidationMetadataArgs';\nimport { ValidationOptions } from '../decorator/ValidationOptions';\n\n/**\n * Used to transform validation schemas to validation metadatas.\n */\nexport class ValidationSchemaToMetadataTransformer {\n  transform(schema: ValidationSchema): ValidationMetadata[] {\n    const metadatas: ValidationMetadata[] = [];\n    Object.keys(schema.properties).forEach(property => {\n      schema.properties[property].forEach(validation => {\n        const validationOptions: ValidationOptions = {\n          message: validation.message,\n          groups: validation.groups,\n          always: validation.always,\n          each: validation.each,\n        };\n        const args: ValidationMetadataArgs = {\n          type: validation.type,\n          target: schema.name,\n          propertyName: property,\n          constraints: validation.constraints,\n          validationTypeOptions: validation.options,\n          validationOptions: validationOptions,\n        };\n        metadatas.push(new ValidationMetadata(args));\n      });\n    });\n    return metadatas;\n  }\n}\n","import { ValidationMetadata } from './ValidationMetadata';\nimport { ConstraintMetadata } from './ConstraintMetadata';\nimport { ValidationSchema } from '../validation-schema/ValidationSchema';\nimport { ValidationSchemaToMetadataTransformer } from '../validation-schema/ValidationSchemaToMetadataTransformer';\nimport { getGlobal } from '../utils';\n\n/**\n * Storage all metadatas.\n */\nexport class MetadataStorage {\n  // -------------------------------------------------------------------------\n  // Private properties\n  // -------------------------------------------------------------------------\n\n  private validationMetadatas: ValidationMetadata[] = [];\n  private constraintMetadatas: ConstraintMetadata[] = [];\n\n  get hasValidationMetaData(): boolean {\n    return !!this.validationMetadatas.length;\n  }\n\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationSchema(schema: ValidationSchema): void {\n    const validationMetadatas = new ValidationSchemaToMetadataTransformer().transform(schema);\n    validationMetadatas.forEach(validationMetadata => this.addValidationMetadata(validationMetadata));\n  }\n\n  /**\n   * Adds a new validation metadata.\n   */\n  addValidationMetadata(metadata: ValidationMetadata): void {\n    this.validationMetadatas.push(metadata);\n  }\n\n  /**\n   * Adds a new constraint metadata.\n   */\n  addConstraintMetadata(metadata: ConstraintMetadata): void {\n    this.constraintMetadatas.push(metadata);\n  }\n\n  /**\n   * Groups metadata by their property names.\n   */\n  groupByPropertyName(metadata: ValidationMetadata[]): { [propertyName: string]: ValidationMetadata[] } {\n    const grouped: { [propertyName: string]: ValidationMetadata[] } = {};\n    metadata.forEach(metadata => {\n      if (!grouped[metadata.propertyName]) grouped[metadata.propertyName] = [];\n      grouped[metadata.propertyName].push(metadata);\n    });\n    return grouped;\n  }\n\n  /**\n   * Gets all validation metadatas for the given object with the given groups.\n   */\n  getTargetValidationMetadatas(\n    targetConstructor: Function,\n    targetSchema: string,\n    always: boolean,\n    strictGroups: boolean,\n    groups?: string[]\n  ): ValidationMetadata[] {\n    const includeMetadataBecauseOfAlwaysOption = (metadata: ValidationMetadata): boolean => {\n      // `metadata.always` overrides global default.\n      if (typeof metadata.always !== 'undefined') return metadata.always;\n\n      // `metadata.groups` overrides global default.\n      if (metadata.groups && metadata.groups.length) return false;\n\n      // Use global default.\n      return always;\n    };\n\n    const excludeMetadataBecauseOfStrictGroupsOption = (metadata: ValidationMetadata): boolean => {\n      if (strictGroups) {\n        // Validation is not using groups.\n        if (!groups || !groups.length) {\n          // `metadata.groups` has at least one group.\n          if (metadata.groups && metadata.groups.length) return true;\n        }\n      }\n\n      return false;\n    };\n\n    // get directly related to a target metadatas\n    const originalMetadatas = this.validationMetadatas.filter(metadata => {\n      if (metadata.target !== targetConstructor && metadata.target !== targetSchema) return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0)\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n      return true;\n    });\n\n    // get metadatas for inherited classes\n    const inheritedMetadatas = this.validationMetadatas.filter(metadata => {\n      // if target is a string it's means we validate against a schema, and there is no inheritance support for schemas\n      if (typeof metadata.target === 'string') return false;\n      if (metadata.target === targetConstructor) return false;\n      if (metadata.target instanceof Function && !(targetConstructor.prototype instanceof metadata.target))\n        return false;\n      if (includeMetadataBecauseOfAlwaysOption(metadata)) return true;\n      if (excludeMetadataBecauseOfStrictGroupsOption(metadata)) return false;\n      if (groups && groups.length > 0)\n        return metadata.groups && !!metadata.groups.find(group => groups.indexOf(group) !== -1);\n\n      return true;\n    });\n\n    // filter out duplicate metadatas, prefer original metadatas instead of inherited metadatas\n    const uniqueInheritedMetadatas = inheritedMetadatas.filter(inheritedMetadata => {\n      return !originalMetadatas.find(originalMetadata => {\n        return (\n          originalMetadata.propertyName === inheritedMetadata.propertyName &&\n          originalMetadata.type === inheritedMetadata.type\n        );\n      });\n    });\n\n    return originalMetadatas.concat(uniqueInheritedMetadatas);\n  }\n\n  /**\n   * Gets all validator constraints for the given object.\n   */\n  getTargetValidatorConstraints(target: Function): ConstraintMetadata[] {\n    return this.constraintMetadatas.filter(metadata => metadata.target === target);\n  }\n}\n\n/**\n * Gets metadata storage.\n * Metadata storage follows the best practices and stores metadata in a global variable.\n */\nexport function getMetadataStorage(): MetadataStorage {\n  const global = getGlobal();\n\n  if (!global.classValidatorMetadataStorage) {\n    global.classValidatorMetadataStorage = new MetadataStorage();\n  }\n\n  return global.classValidatorMetadataStorage;\n}\n","import { ValidationOptions } from '../ValidationOptions';\nimport { registerDecorator } from '../../register-decorator';\nimport { ValidationArguments } from '../../validation/ValidationArguments';\nimport { ValidatorConstraintInterface } from '../../validation/ValidatorConstraintInterface';\n\nexport interface ValidateByOptions {\n  name: string;\n  constraints?: any[];\n  validator: ValidatorConstraintInterface | Function;\n  async?: boolean;\n}\n\nexport function buildMessage(\n  impl: (eachPrefix: string, args?: ValidationArguments) => string,\n  validationOptions?: ValidationOptions\n): (validationArguments?: ValidationArguments) => string {\n  return (validationArguments?: ValidationArguments): string => {\n    const eachPrefix = validationOptions && validationOptions.each ? 'each value in ' : '';\n    return impl(eachPrefix, validationArguments);\n  };\n}\n\nexport function ValidateBy(options: ValidateByOptions, validationOptions?: ValidationOptions): PropertyDecorator {\n  return function (object: object, propertyName: string): void {\n    registerDecorator({\n      name: options.name,\n      target: object.constructor,\n      propertyName: propertyName,\n      options: validationOptions,\n      constraints: options.constraints,\n      validator: options.validator,\n    });\n  };\n}\n","import { ConstraintMetadata } from './metadata/ConstraintMetadata';\nimport { ValidatorConstraintInterface } from './validation/ValidatorConstraintInterface';\nimport { ValidationMetadata } from './metadata/ValidationMetadata';\nimport { ValidationMetadataArgs } from './metadata/ValidationMetadataArgs';\nimport { ValidationTypes } from './validation/ValidationTypes';\nimport { ValidationArguments } from './validation/ValidationArguments';\nimport { getFromContainer } from './container';\nimport { MetadataStorage, getMetadataStorage } from './metadata/MetadataStorage';\nimport { ValidationOptions } from './decorator/ValidationOptions';\n\nexport interface ValidationDecoratorOptions {\n  /**\n   * Target object to be validated.\n   */\n  target: Function;\n\n  /**\n   * Target object's property name to be validated.\n   */\n  propertyName: string;\n\n  /**\n   * Name of the validation that is being registered.\n   */\n  name?: string;\n\n  /**\n   * Indicates if this decorator will perform async validation.\n   */\n  async?: boolean;\n\n  /**\n   * Validator options.\n   */\n  options?: ValidationOptions;\n\n  /**\n   * Array of validation constraints.\n   */\n  constraints?: any[];\n\n  /**\n   * Validator that performs validation.\n   */\n  validator: ValidatorConstraintInterface | Function;\n}\n\n/**\n * Registers a custom validation decorator.\n */\nexport function registerDecorator(options: ValidationDecoratorOptions): void {\n  let constraintCls: Function;\n  if (options.validator instanceof Function) {\n    constraintCls = options.validator;\n    const constraintClasses = getFromContainer(MetadataStorage).getTargetValidatorConstraints(options.validator);\n    if (constraintClasses.length > 1) {\n      throw `More than one implementation of ValidatorConstraintInterface found for validator on: ${options.target.name}:${options.propertyName}`;\n    }\n  } else {\n    const validator = options.validator;\n    constraintCls = class CustomConstraint implements ValidatorConstraintInterface {\n      validate(value: any, validationArguments?: ValidationArguments): Promise<boolean> | boolean {\n        return validator.validate(value, validationArguments);\n      }\n\n      defaultMessage(validationArguments?: ValidationArguments): string {\n        if (validator.defaultMessage) {\n          return validator.defaultMessage(validationArguments);\n        }\n\n        return '';\n      }\n    };\n    getMetadataStorage().addConstraintMetadata(new ConstraintMetadata(constraintCls, options.name, options.async));\n  }\n\n  const validationMetadataArgs: ValidationMetadataArgs = {\n    type: options.name && ValidationTypes.isValid(options.name) ? options.name : ValidationTypes.CUSTOM_VALIDATION,\n    target: options.target,\n    propertyName: options.propertyName,\n    validationOptions: options.options,\n    constraintCls: constraintCls,\n    constraints: options.constraints,\n  };\n  getMetadataStorage().addValidationMetadata(new ValidationMetadata(validationMetadataArgs));\n}\n","/**\n * This function returns the global object across Node and browsers.\n *\n * Note: `globalThis` is the standardized approach however it has been added to\n * Node.js in version 12. We need to include this snippet until Node 12 EOL.\n */\nexport function getGlobal() {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: Cannot find name 'window'.\n  if (typeof window !== 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'window'.\n    return window;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore: Cannot find name 'self'.\n  if (typeof self !== 'undefined') {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore: Cannot find name 'self'.\n    return self;\n  }\n}\n"],"sourceRoot":""}