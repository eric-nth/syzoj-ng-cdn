{"version":3,"sources":["../node_modules/flat/index.js"],"names":["isBuffer","obj","constructor","keyIdentity","key","flatten","target","opts","delimiter","maxDepth","transformKey","output","step","object","prev","currentDepth","Object","keys","forEach","value","isarray","safe","Array","isArray","type","prototype","toString","call","isbuffer","isobject","newKey","length","module","exports","unflatten","overwrite","result","getkey","parsedKey","Number","isNaN","indexOf","reduce","val","isObject","isEmpty","keyPrefix","recipient","addKeys","split","map","key1","shift","key2","undefined"],"mappings":"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","file":"static/js/85.5666b7cc.chunk.js","sourcesContent":["module.exports = flatten\nflatten.flatten = flatten\nflatten.unflatten = unflatten\n\nfunction isBuffer (obj) {\n  return obj &&\n    obj.constructor &&\n    (typeof obj.constructor.isBuffer === 'function') &&\n    obj.constructor.isBuffer(obj)\n}\n\nfunction keyIdentity (key) {\n  return key\n}\n\nfunction flatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const maxDepth = opts.maxDepth\n  const transformKey = opts.transformKey || keyIdentity\n  const output = {}\n\n  function step (object, prev, currentDepth) {\n    currentDepth = currentDepth || 1\n    Object.keys(object).forEach(function (key) {\n      const value = object[key]\n      const isarray = opts.safe && Array.isArray(value)\n      const type = Object.prototype.toString.call(value)\n      const isbuffer = isBuffer(value)\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      const newKey = prev\n        ? prev + delimiter + transformKey(key)\n        : transformKey(key)\n\n      if (!isarray && !isbuffer && isobject && Object.keys(value).length &&\n        (!opts.maxDepth || currentDepth < maxDepth)) {\n        return step(value, newKey, currentDepth + 1)\n      }\n\n      output[newKey] = value\n    })\n  }\n\n  step(target)\n\n  return output\n}\n\nfunction unflatten (target, opts) {\n  opts = opts || {}\n\n  const delimiter = opts.delimiter || '.'\n  const overwrite = opts.overwrite || false\n  const transformKey = opts.transformKey || keyIdentity\n  const result = {}\n\n  const isbuffer = isBuffer(target)\n  if (isbuffer || Object.prototype.toString.call(target) !== '[object Object]') {\n    return target\n  }\n\n  // safely ensure that the key is\n  // an integer.\n  function getkey (key) {\n    const parsedKey = Number(key)\n\n    return (\n      isNaN(parsedKey) ||\n      key.indexOf('.') !== -1 ||\n      opts.object\n    ) ? key\n      : parsedKey\n  }\n\n  function addKeys (keyPrefix, recipient, target) {\n    return Object.keys(target).reduce(function (result, key) {\n      result[keyPrefix + delimiter + key] = target[key]\n\n      return result\n    }, recipient)\n  }\n\n  function isEmpty (val) {\n    const type = Object.prototype.toString.call(val)\n    const isArray = type === '[object Array]'\n    const isObject = type === '[object Object]'\n\n    if (!val) {\n      return true\n    } else if (isArray) {\n      return !val.length\n    } else if (isObject) {\n      return !Object.keys(val).length\n    }\n  }\n\n  target = Object.keys(target).reduce(function (result, key) {\n    const type = Object.prototype.toString.call(target[key])\n    const isObject = (type === '[object Object]' || type === '[object Array]')\n    if (!isObject || isEmpty(target[key])) {\n      result[key] = target[key]\n      return result\n    } else {\n      return addKeys(\n        key,\n        result,\n        flatten(target[key], opts)\n      )\n    }\n  }, {})\n\n  Object.keys(target).forEach(function (key) {\n    const split = key.split(delimiter).map(transformKey)\n    let key1 = getkey(split.shift())\n    let key2 = getkey(split[0])\n    let recipient = result\n\n    while (key2 !== undefined) {\n      if (key1 === '__proto__') {\n        return\n      }\n\n      const type = Object.prototype.toString.call(recipient[key1])\n      const isobject = (\n        type === '[object Object]' ||\n        type === '[object Array]'\n      )\n\n      // do not write over falsey, non-undefined values if overwrite is false\n      if (!overwrite && !isobject && typeof recipient[key1] !== 'undefined') {\n        return\n      }\n\n      if ((overwrite && !isobject) || (!overwrite && recipient[key1] == null)) {\n        recipient[key1] = (\n          typeof key2 === 'number' &&\n          !opts.object ? [] : {}\n        )\n      }\n\n      recipient = recipient[key1]\n      if (split.length > 0) {\n        key1 = getkey(split.shift())\n        key2 = getkey(split[0])\n      }\n    }\n\n    // unflatten again for 'messy objects'\n    recipient[key1] = unflatten(target[key], opts)\n  })\n\n  return result\n}\n"],"sourceRoot":""}